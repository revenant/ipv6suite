#!/usr/bin/env ruby
#
#  Author: Johnny Lai
#  Copyright (c) 2004 Johnny Lai
#
# =DESCRIPTION
# CMakeLists.txt generater for omnetpp type projects. Currently works with INET
# and generates IPv6Suite's OneBigExe.cmake but should work for others too. 
#

#Pattern for doing wildcard matches of filenames recursively i.e. subdirectories too 
RECURSEDIR="**/*"

#Extension of files used for message subclassing
MSGEXT=".msg"
NEDEXT=".ned"

def traverseDirectory(dir, expression, ignore = nil)
  oldpwd = Dir.pwd
  Dir.chdir(dir)
  arr = Array.new
  Dir[expression].each {|f|
    next if ignore and f =~ Regexp.new(ignore)
    arr.push(f)
  }
  arr
ensure
  Dir.chdir(oldpwd)
end

def customCommands(dir, ignorePattern,projName)  
  
  m = traverseDirectory(dir,RECURSEDIR+MSGEXT, ignorePattern)
 
  return "" if m.size == 0
  string = "\nOPP_WRAP_MSGC(dum dum2 #{m.join("\n")}\n)\n"
	#the following will include all msg files in all subdirs
	#string += "\nOPP_WRAP_MSGC_ALL()\n"  
end

def createNedFilesList(dir, ignorePattern)  
  m = traverseDirectory(dir,RECURSEDIR+NEDEXT, ignorePattern)
  string = "#{m.join("\n")}"
  open("#{dir}/nedfiles.lst","w") {  |x|
    x.print string
  }
end

def addSourceFiles(dir, ignorePattern)
  c = traverseDirectory(dir, RECURSEDIR+".{h,cc,cpp,c}", ignorePattern)

  includeDirs = Array.new
  c.delete_if {|f| 
    header = f =~ /\.h$/     
    includeDirs.push(File.dirname(f)) if header and not includeDirs.include? File.dirname(f) 
    header
  }
  Array[c, includeDirs]
end

def addTests(dir)
  c = traverseDirectory(dir, RECURSEDIR + ".test")
  testDirs = Array.new
  c.each{ |test|
    testDirs.push(File.dirname(test)) if not testDirs.include? File.dirname(test)
  }
  testDirs
end

def writeTest(testDirs, projName)
  testDirs.each{ |d|
    open("#{d}/CMakeLists.txt","w") { |testCMake|
      testCMake.puts "LINK_LIBRARIES(#{projName} ${OPP_LIBRARIES})"
      testCMake.puts "OPP_WRAP_TEST(#{File.basename(d)})" 
    }
  }  
end

  OldRTPDeps = "|Scenario|RSVP|MPLS"

def writeCMakeList(dir, outputName, projName = nil)
				#EtherSwitch
#Contract requires IPv4
#ARP|IPv4|TCP|FlatNetwork|Queue
  commonIgnore =
	"scripts|Scalars|Research|CMake|Unsupported|_m\.|test|Topology|PPP/|LDP|Tests|IPv4d" + OldRTPDeps
  
  sources, includes = addSourceFiles(dir, commonIgnore)    
  
  projName ||= File.basename(dir)  
  
  open("#{dir}/#{outputName}","w") {  |x|

    x.puts "# -*- CMAKE -*-"
    x.puts %{#Generated by "#{$0} #{ARGV.join(" ")}"}

    if not @customise
      x.puts("PROJECT(#{projName})") if projName and projName.length > 0
     
xvar = <<EOF
# set_dir_props generated from customCommands requires this
CMAKE_MINIMUM_REQUIRED(VERSION 2.0)
SET(CMAKE_BACKWARDS_COMPATIBILITY 2.0 CACHE STRING "2.4 uses default path before our custom path for omnet libs unless we do NO_DEFAULT_PATH in every FIND_LIBRARY" FORCE)

SET(OPP_USE_TK OFF CACHE BOOL "OFF unless you are sure tk gui can build")
SET(OPP_USE_MPI OFF CACHE BOOL "OFF unless you are sure lam libs are not 64bit")

SET(CMAKEFILES_PATH ${PROJECT_SOURCE_DIR}/Etc/CMake)
SET(MISCDIR ${PROJECT_SOURCE_DIR}/Etc)
SET(SCRIPTDIR ${MISCDIR}/scripts)
OPTION(BUILD_SHARED_LIBS "Build with shared libraries." ON)
SET(ONE_BIG_EXE ON)

INCLUDE(${CMAKEFILES_PATH}/Options.cmake)

INCLUDE(${CMAKEFILES_PATH}/IntelICCOptions.cmake)

#INCLUDE(${CMAKE_ROOT}/Modules/Dart.cmake)

INCLUDE(${CMAKEFILES_PATH}/Configure.cmake)

INCLUDE(${CMAKEFILES_PATH}/Macros.cmake)

IF(NOT WIN32)
  INCLUDE(${CMAKEFILES_PATH}/DocTargets.cmake)
ENDIF(NOT WIN32)

INCLUDE(${CMAKEFILES_PATH}/LinkLibraries.cmake)

ADD_DEFINITIONS(-DBOOST_WITH_LIBS -DWITH_IPv6 -DUSE_MOBILITY -DFASTRS -DFASTRA -DUSE_HMIP -DEDGEHANDOVER=1)
 
INCLUDE_DIRECTORIES(${OPP_INCLUDE_PATH})
INCLUDE_DIRECTORIES(${PROJECT_BINARY_DIR})
#By default on Linux env this is usually same as /usr/include
#But just in case not include it too
INCLUDE_DIRECTORIES(${BOOSTROOT})

IF(WIN32)
  #include windows specific includes/lib dirs part of SDK and
  #VC (run vcvars32.bat in console before cmakesetup)
  INCLUDE_DIRECTORIES($ENV{INCLUDE})
  FIND_LIBRARY(USER32 wsock32 $ENV{LIB})
  ADD_DEFINITIONS(/NODEFAULTLIB:MSVCRTD /NODEFAULTLIB:LIBCMT)
ENDIF(WIN32)

EOF
      x.puts xvar
      if `hostname` =~ /hn\d/
      x.puts %|SET(CMAKE_CXX_FLAGS -m32 CACHE STRING "build 32bit" FORCE)
SET(CMAKE_SHARED_LINKER_FLAGS -m32 CACHE STRING "build 32bit" FORCE)
IF(LIBCWD_DEBUG)
  ADD_DEFINITIONS(-DPLATFORM64bit=1 -DCWDEBUG_ALLOC=1)
ENDIF(LIBCWD_DEBUG)
|

      end
    end

    createNedFilesList(dir, commonIgnore + "|Examples|Research")
    customCommandsLines = customCommands(dir, commonIgnore, projName)
    
    x.print customCommandsLines

    #It appears that these source files properties only exist in the current
    #Dir/cmakelist.txt because in subdir's cmakelist.txt cannot use the source
    #file here as it complains source does not exist unless we also set generated property in there for these files again 
    #this does not work however
    #x.print "SET_SOURCE_FILES_PROPERTIES(${GENERATED_MSGC_FILES} GENERATED PROPERTIES COMPILE_FLAGS -Wall)\n\n"

    x.print "\nSET( ", projName, "_SRCS\n"

    #necessary otherwise any subsequent SUBDIRS commands will change
    #the relative source file to an incorrect absolute path
    basepath="${PROJECT_SOURCE_DIR}/"
    
    sources.each{|c| 
      x.puts basepath + c
    }

    x.puts ")"

    xvar = ""
xvar = <<EOF
SET_SOURCE_FILES_PROPERTIES(${#{projName}_SRCS} PROPERTIES  COMPILE_FLAGS ${COMPILER_WARNINGS})
SET(#{projName}_SRCS ${GENERATED_MSGC_FILES} ${#{projName}_SRCS})


EOF
    
    xvar.insert(0, "SET(COMPILER_WARNINGS -Wall)\n") if @customise
    x.puts xvar
    x.puts "INCLUDE_DIRECTORIES("
    includes.each{|inc|         
      x.puts basepath + inc
    }
    x.puts ")\n\n"

   if @customise

# No longer works cause simplemodules don't export their type no more in gcc output
     x.puts %|OPTION(BUILD_SHARED_LIBS "Build with shared libraries." ON)|
     x.puts(sprintf("ADD_LIBRARY(%s ${%s})\n", projName, projName + "_SRCS"))
   else
#      outputdir = projName == "INET" ? "bin" : "."
      outputdir = "."


xvar = <<EOF
SET(LIBRARY_OUTPUT_PATH ${CMAKE_CURRENT_BINARY_DIR}/lib)

IF(NOT WIN32)
#Windows does not recognise ./ as current dir
  SET(OUTPUTDIR #{outputdir}/)
ENDIF(NOT WIN32)

ADD_LIBRARY(inet ${INET_SRCS})

SET(DUMMY_FILE ${CMAKE_CURRENT_BINARY_DIR}/empty.cc)
FILE(WRITE ${DUMMY_FILE} "//empty file\n")
 
SET(#{projName} ${OUTPUTDIR}#{projName})
ADD_EXECUTABLE(${#{projName}} ${DUMMY_FILE})
TARGET_LINK_LIBRARIES(${#{projName}} inet ${OPP_CMDLIBRARIES} )

IF(NOT LIBCWD_DEBUG)
  IF(OPP_USE_TK)
    SET(tk#{projName} ${OUTPUTDIR}tk#{projName})
    ADD_EXECUTABLE(${tk#{projName}} ${DUMMY_FILE})
    TARGET_LINK_LIBRARIES(${tk#{projName}} inet ${OPP_TKGUILIBRARIES} )
  ENDIF(OPP_USE_TK)
ENDIF(NOT LIBCWD_DEBUG)

IF(NOT WIN32)
ENABLE_TESTING()
OPP_WRAP_TEST(Tests)
INCLUDE(FindRuby)
IF (RUBY_EXECUTABLE)
SUBDIRS(
Etc/scripts/
)
ENDIF (RUBY_EXECUTABLE)
SUBDIRS(
Research/Networks/
)
ENDIF(NOT WIN32)

EOF
      x.puts xvar
    end
  }
end

## main

if ARGV.length < 2 then
  @customise = true
  writeCMakeList(".", "CMakeLists.txt", ARGV[0])
  exit
else
  print "Usage ",  " <source dir name> <Project Name>\n", \
  " where [source dir] is where CMakeLists.txt will be generated for\n", \
  "Generated in current working directory"

  projName = ARGV[1]
	#customise used to be for making OneBigStaticExe.cmake except forgot how to generate sourcelist 
  @customise = false
  outname = @customise ? "OneBigStaticExe.cmake" : "CMakeLists.txt"
  writeCMakeList(ARGV[0], outname, projName)
end
